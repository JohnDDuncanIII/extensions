# Description Localization
extensions.{SQLiteManager@mrinalkant.blogspot.com}.description=SQLite-Datenbank-Manager für Mozilla-Anwendungen.
dbDoesNotExist=Die Datei ist nicht vorhanden: %1$S
lastDbDoesNotExist=Die Datei existiert nicht mehr:
promptLastDbTitle=Mit letzter Datenbank öffnen?
promptLastDbAsk=Möchten Sie die zuletzt verwendete Datenbank öffnen: 
promptLastDbOpen=Nicht wieder nachfragen und immer zuletzt verwendete Datenbank öffnen.
dropColumn=Spalte löschen
alterColumn=Spalte ändern
allowed=Erlaubt
notAllowed=Nicht erlaubt
noRecord=Kein Datensatz ausgewählt
firstOpenADb=Sie müssen zuerst eine Datenbank öffnen.
writeSomeSql=Bitte notieren Sie einen SQL-Befehl und führen Sie ihn anschließend aus.
importData=Daten importieren
noDbOrTable=Keine Datenbank und/oder Tabelle ausgewählt.
noDb=Keine Datenbank ausgewählt
onlyOneRecord=Nur einen einzelnen Datensatz zum Bearbeiten auswählen.
selectProfileDb=(Profil-Datenbank auswählen)
selectDbInDefaultDir=(DB im Standard-Verzeichnis auswählen)
invalidProfileDb=Unzulässige Auswahl. Bitte eine Datei aus dem Drop-down-Menü auswählen.
extName=SQLite Manager
sqlite=SQLite
filesInProfileDbList=Anzahl an Dateien im ausgewählten Verzeichnis
dropDone=DROP erfolgreich
noObjectToDelete=Löschen fehlgeschlagen, es existiert kein Objekt dieses Typs
selectDb=SQLite-Datenbank auswählen
ok=OK
notOk=Nicht OK
sqliteDbFiles=SQLite-DB-Dateien
copyFailed=Kopieren fehlgeschlagen. Möchten Sie eine neue Datenbank anlegen?
noOpenDb=Keine geöffnete Datenbank gefunden
loadDataFailed=Laden der Daten fehlgeschlagen.
rowsReturned=Anzahl zurückgegebener Zeilen
selectFolderForDb=Verzeichnis auswählen, in dem DB-Datei gespeichert werden soll
dbFileExists=Eine Datei mit dem angegebenen Namen existiert bereits. Sie öffnen eine vorhandene Datenbank
confirmClose=Sind Sie sicher, dass Sie die aktuell geöffnete Datenbank schließen möchten?
confirmBackup=Möchten Sie von dieser Datenbank-Datei vor dem Öffnen eine Sicherungskopie anlegen?
integrityResultPrefix=Integrität der Datenbank geprüft.\nErgebnis
pragma.changed=PRAGMA: %1$S: Der Wert wurde geändert in %2$S
confirm.changeSchemaVersion=Die Schema-Version wird normalerweise nur intern von SQLite manipuliert. Es wird von SQLite erhöht, sobald das Datenbankschema geändert wird (durch Erstellen oder Löschen einer Tabelle oder eines Indexes). Die Schema-Version wird von SQLite benutzt, jedes Mal, wenn eine Abfrage ausgeführt wird, um sicherzustellen, dass der interne Speicher des Schemas, der beim Kompilieren der SQL-Abfrage mit dem Schema der Datenbank, gegen die die Abfrage ausgeführt wird, übereinstimmt. Das Untergraben dieses Mechanismus durch Benutzung von 'PRAGMA schema_version' ist potenziell gefährlich und könnte Programmabstürze und Datenbankkorruption nach sich ziehen. Benutzen Sie es mit Vorsicht!
dangerous.op=Gefährliche Operation
q.proceed=Möchten Sie dennoch fortfahren?
vacuum.title=Ergebnis der Komprimierung
vacuum.details=Die Datenbank wurde unter Verwendung des VACUUM-Statements komprimiert.\nVor dem Komprimieren:\n\tSeitenanzahl = %1$S\n\tDatenbankgröße = %2$S Bytes\nNachdem komprimieren:n\tSeitenanzahl = %3$S\n\tDatenbankgröße = %4$S bytes
#
createMngr.index.title=Index auf Tabelle %1$S erstellen
createMngr.index.donotuse=Nicht verwenden
createMngr.index.ascending=Aufsteigend
createMngr.index.descending=Absteigend
createMngr.index.cannotBeNull=Name kann nicht null sein
createMngr.index.noFieldsSelected=Keine Felder ausgewählt
createMngr.index.confirm=Index %1$S erstellen
createMngr.dropColumn=Spalte %1$S von %2$S entfernen
createMngr.alterColumn=Spalte %1$S in Tabelle %2$S verändern
createMngr.tbl.cannotBeNull=Tabellenname kann nicht null sein
createMngr.tbl.cannotBeginSqlite=Tabellenname kann nicht mit sqlite_ anfangen
createMngr.invalidColname=Spaltenname kann nicht zu rowid, _rowid, oid gehören
createMngr.autoincError.cols=AUTOINCREMENT an mehr als einer Spalte ist nicht möglich.
createMngr.autoincError.PK=AUTOINCREMENT nicht erlaubt, wenn der primäre Schlüssel über zwei oder mehr Spalten ist.
createMngr.modifyView=Ansicht ändern
createMngr.view.cannotBeNull=Name kann nicht null sein
createMngr.statement.cannotBeNull=Statement kann nicht null sein
createMngr.trigger.cannotBeNull=Name kann nicht null sein
createMngr.trigger.cannotBeEmpty=Trigger-Schritte können nicht leer sein
createMngr.trigger.confirm=Trigger %1$s erstellen
#
eximTab.import.label=Importassistent
eximTab.export.label=Exportassistent
eximTab.export.subtitle=%1$s exportieren:
eximLblNameOfTable=Name of the Table
eximLblNameOfView=Name of the View
eximTab.export.label02=Exportassistent: %1$S exportieren:
exim.exportToFile=Nach Datei exportieren
exim.chooseFileExport=Bitte wählen Sie eine Datei, in der Sie die exportierten Daten speichern möchten.
exim.exportNum=%1$S Datensätze exportiert nach %2$S
exim.chooseFileImport=Datei zum Importieren wählen
exim.alertNull.title=SQLite Manager - Importfehler
exim.alertNull.msg=Importfehler: Keine Datei aus der importiert werden kann!\nBitte wählen Sie die Datei, die die Daten enthält, die Sie importieren möchten.
exim.importNum.title=Import:
exim.importNum.statements=%1$S Statements ausgeführt
exim.importNum.records=%1$S Datensätze importiert.
exim.importFailed=Importfehler: Import fehlgeschlagen.
exim.importCancelled=Import abgebrochen.
exim.import.tablename=Geben Sie den Namen der Tabelle ein, in die die Daten importiert werden:
exim.import.invalidTablename=Importfehler: Bitte geben Sie einen gültigen Tabellennamen ein.
exim.confirm.rows.title=SQLite Manager
exim.confirm.rows.msg=Sind Sie sicher, dass Sie die folgende(n) Operation(en) durchführen möchten:\nDaten importieren: Reihen =
exim.import.failed=Import von %1$S Zeilen fehlgeschlagen.\n Zeilennummern:
exim.confirm.sqlStats.title=SQLite Manager
exim.confirm.sqlStats.msg=Sind Sie sicher, dass Sie die folgende(n) Operation(en) durchführen möchten:\nDaten durch Ausführen von SQL-Statements importieren: Anzahl von SQL-Statements:
exim.confirm.irows.title=SQLite Manager
exim.confirm.irows.msg=Sind Sie sicher, dass Sie die folgende(n) Operation(en) ausführen möchten:\Daten importieren: Reihen =
exim.confirm.tabName.title=SQLite Manager
exim.confirm.tabName.msg=Sind Sie sicher, dass Sie die Daten in eine existierende Tabelle %1$S importieren möchten?\nKlicken Sie auf OK, um mit dem Import fortzufahren.
exim.confirm.createTable.title=SQLite Manager
exim.confirm.createTable.msg=Eine neue Tabelle mit dem Namen %1$S wird angelegt. Möchten Sie diese Tabelle bearbeiten?\nKlicken Sie zum Bearbeiten auf OK.
#
extManager.dropTableConfirm=Sind Sie sicher, dass Sie die Tabelle %1$S löschen möchten?\nSie verlieren alle Daten, die mit dem Abfrage-Verlauf im SQL ausführen-Tab in Bezug stehen.
extManager.deleteQueries=Alle gespeicherten Abfragen von Tabelle löschen:
extManager.qName.enter=Geben Sie den Namen für die Abfrage ein, die Sie speichern möchten
extManager.qName.exists=Eine Abfrage mit dem gewählten Namen existiert bereits.
#
globals.confirm.msg=Sind Sie sicher, dass Sie die folgende(n) Operation(en) ausführen möchten:
globals.confirm.title=Operation bestätigen
#
rowOp.insert.title=Neuen Datensatz hinzufügen
rowOp.insertSuccess.msg=Datensatz erfolgreich eingefügt. Sie können jetzt einen weiteren Datensatz hinzufügen. Drücken Sie Abbrechen, um diesen Dialog zu schließen.
rowOp.insertFailure.msg=Fehler beim Einfügen des Datensatzes. Sie können nun einen neuen Datensatz hinzufügen. Drücken Sie Abbrechen, um diesen Dialog zu schließen.
rowOp.update.title=Datensatz bearbeiten
rowOp.updateSuccess.msg=Datensatz erfolgreich aktualisiert. Drücken Sie Abbrechen, um diesen Dialog zu schließen.
rowOp.updateFailure.msg=Fehler beim Aktualisieren des Datensatzes. Drücken Sie Abbrechen, um diesen Dialog zu schließen.
rowOp.delete.title=Datensatz löschen
rowOp.search.title=In Tabelle suchen
rowOp.searchView.title=In Ansicht suchen
rowOp.enterFieldValues=Feldwerte eingeben
rowOp.saveBlob.fp.title=Blob in Datei speichern
rowOp.addBlob.fp.title=Blob-Datei wählen
rowOp.addBlob.showBlobSize=(Größe: %1$S)
rowOp.tooltip.expandInput=Eingabebereich erweitern
rowOp.tooltip.collapseInput=Eingabebereich einklappen
rowOp.tooltip.addBlob=Datei als Blob hinzufügen
rowOp.tooltip.saveBlob=Blob-Daten in Datei speichern
rowOp.tooltip.deleteBlob=Blob-Daten von dieser Spalte löschen
rowOp.viewName=Anzeigename
rowOp.noChanges=Es wurde kein Feld geändert. Sie können die Schaltfläche Abbrechen drücken, um den Vorgang abzubrechen.
rowOp.confirmation=Sind Sie sicher, dass Sie folgende(s) Statement(s) ausführen möchten:
#
sqlite.size=(Größe:%1$S)
sqlite.blobSize=BLOB (Größe:%1$S)
sqlite.confirm.deleteRecords=Alle Datensätze löschen
sqlite.confirm.renameTable=Tabelle %1$S umbenennen
sqlite.confirm.analyzeTable=Tabelle analysieren
sqlite.confirm.addColumn=Spalte zu Tabelle %1$S hinzufügen
#
sqlm.selectQuery=Eine Abfrage auswählen
sqlm.noForeignKey=Bei dieser Tabelle ist kein Fremdschlüssel definiert.
sqlm.fKeyNoTable=Fehlgeschlagen: Die Tabelle, auf die verwiesen wird, existiert nicht
sqlm.fKeySelfReference=Fehlgeschlagen: Mindestens ein Fremdschlüssel verweist selbst auf diese Tabelle
sqlm.fKeyUnnamedColumn=Fehlgeschlagen: Die Spalte %1$S bezog sich auf eine unbenannte Spalte (möglicherweise verursacht durch eine indirekte Referenz, welche nicht verarbeitet wird)
sqlm.confirm.title=Den Vorgang bestätigen
sqlm.confirm.msg=Möchten Sie diese Trigger für die Fremdschlüssel erstellen?\n\n
sqlm.nothingToSave=Nichts zu speichern.
sqlm.enterDatabaseName=Geben Sie den Datenbanknamen ein (%1$S wird automatisch an den Namen angehängt)
sqlm.enterDatabaseName.title=Geben Sie den Datenbanknamen ein
sqlm.enterADSName=Geben Sie den ADS-Namen ein
sqlm.enterADSName.descr=Geben Sie den Namen der ADS ein, die die sqlite db enthält
sqlm.alert.fileNotFound=Datei nicht gefunden:
sqlm.confirm.createTable=Tabelle %1$S erstellen
sqlm.confirm.createObj=%1$S %2$S erstellen
sqlm.confirm.modifyView=Ansicht %1$S ändern
sqlm.confirm.dangerousOp=Dies ist ein potenziell gefährlicher Vorgang. SQLite unterstützt keine Statements, die eine Spalte in einer Tabelle ändern können. Nachfolgend wird versucht, das neue CREATE SQL-Statement neu zu konstruieren, durch Auslesen von pragma table_info, welche keine vollständigen Informationen über die Struktur der vorhandenen Tabelle enthält.\n\n
sqlm.alterColumn.name=Bitte geben Sie den neuen Namen der Spalte ein
#
sqlm.export.fp.title=Nach Datei exportieren
sqlm.export.fp.descr=Bitte wählen Sie eine Datei, in der Sie die exportierten Daten speichern möchten.
sqlm.export.db=Datenbank exportiert nach %1$S
sqlm.export.dbstructure=Datenbankstruktur exportiert nach %1$S
sqlm.export.tables=%1$S Tabellen exportiert nach %2$S
sqlm.renameTable=Tabelle %1$S umbenennen
sqlm.renameTable.descr=Geben Sie den neuen Namen der Tabelle ein
sqlm.renameTable.confirm=Tabelle %1$S umbenennen
sqlm.renameObj=%1$S %2$S umbenennen
sqlm.renameObj.descr=Geben Sie den neuen Namen der %1$S ein
sqlm.renameObj.newSqlFailed=Erstellen des SQL-Statements fehlgeschlagen
sqlm.renameObj.confirm=%1$S %2$S umbenennen
sqlm.copyTable.newSqlFailed=Erstellen des SQL-Statements zum Kopieren der Tabelle fehlgeschlagen.
sqlm.copyTable.confirm=Die Tabelle kopieren
sqlm.deleteRecs=%1$S Datensätze von %2$S löschen
sqlm.selectDefaultDir=Standardverzeichnis wählen
sqlm.tooltip.profileDir=Profilverzeichnis
sqlm.detachDb.alert=Dieser Eintrag kann nicht abgetrennt werden. Dieser Vorgang ist nur bei einer angehängten Datenbank gültig.
sqlm.detachDb.confirm=Sind Sie sicher, dass Sie die Datenbank %1$S abtrennen möchten?\nDer Pfad der angehängten Datenbank ist:
sqlm.detachDb.msgOk=Datenbank %1$S abgetrennt.
sqlm.detachDb.msgFailed=Datenbank %1$S konnte nicht abgetrennt werden.
sqlm.attachDb=Datenbank %1$S anhängen
sqlm.attachDb.descr=Geben Sie den Datenbanknamen ein
sqlm.attachDb.msgOk=Datenbank %1$S angehängt als %2$S
sqlm.attachDb.msgFailed=Datenbank %1$S konnte nicht angehängt werden.
sqlm.backup.failed=Fehler beim Erstellen der Sicherungsdatei: %1$S\nFehlermeldung: %2$S Kopie
sqlm.tooltip.tempObj=Temporäre Objekte
sqlm.tooltip.tempDbObj=Temporäre DB-Objekte
sqlm.tooltip.attachedDbs=--- Angehängte Datenbanken ---
defaultval.title=Kein Standardwert
defaultval.message=Mit dieser Spalte ist kein Standardwert verknüpft
udf.newFunctionArgLength=Die Anzahl an Argumenten, die die Funktion akzeptiert, sollte ein Integer sein.\n-1 bedeutet unendliche Anzahl an Argumenten.
udf.newFunctionBody=Write the function body without braces.\nThe argument to the function is "aValues" which can be used within the function body as in the example functions which you can see under the Simple Functions tab.
udf.newFunctionOnStepBody=Write the function body without braces.\nThe argument to the function is "aValues" which can be used within the function body as in the example functions which you can see under the Aggregate Functions tab.\nAny values you need to store for use in onFinal() can be stored in this._store which is initialized as an empty array
udf.newFunctionOnFinalBody=Write the function body without braces.\nThis function takes no arguments. See an example under the Aggregate Functions tab.\nYou can use this._store for computation in this function after you have stored values in it in the onStep() function.
connectSql.forAllDb=You can enter a number of SQL statements (separated by ;) which you would like to be executed immediately after a connection is made to any sqlite database.\n\nAs an example, I like to execute "PRAGMA foreign_keys = 1" immediately after connecting to any database. If I enter this pragma statement in the following textbox and save it, then I do not need to strain myself to remember this, type it and run it every time I connect to a database.\n\nThese statements are stored in a preference called "extensions.sqlitemanager.onConnectSql".
connectSql.forThisDb=You can enter a number of SQL statements (separated by ;) which you would like to be executed immediately after a connection is made to this sqlite database. This functionality is on a per-database basis.\n\nThese SQL statements are stored in this database itself in the table used to store extension data.\n\nThis functionality can be enabled from the Tools menu. After enabling this functionality, please Reload this tab to enable editing.
